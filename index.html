<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FudidoFlix - O Seu Streaming, As Suas Regras</title>
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="https://i.imgur.com/Cu1XfRE.png">
    <!-- Inclui o Tailwind CSS para estilização rápida -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inclui o Font Awesome para ícones -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Fonte Inter do Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos personalizados para emular a aparência da Netflix */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #141414;
        }
        .bg-netflix-main { background-color: #141414; }
        .bg-netflix-secondary { background-color: #202020; }
        .text-netflix-red { color: #E50914; }
        .btn-netflix-red { background-color: #E50914; color: white; }
        .btn-netflix-red:hover { background-color: #f6121d; }
        /* Gradientes para dar profundidade às imagens de fundo */
        .modal-gradient { background: linear-gradient(to right, rgba(20, 20, 20, 1) 0%, rgba(20, 20, 20, 0.8) 50%, transparent 100%); }

        /* Scrollbar personalizada */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: #181818; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        /* Animação de carregamento (Spinner) */
        .loader {
            width: 50px; height: 50px;
            border: 5px solid #444;
            border-bottom-color: #E50914;
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- ESTILOS DO CARROSSEL --- */
        .carousel-container {
            position: relative;
        }
        .carousel {
            -ms-overflow-style: none;  /* IE e Edge */
            scrollbar-width: none;  /* Firefox */
        }
        .carousel::-webkit-scrollbar {
            display: none; /* WebKit */
        }
        .carousel-arrow {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 4%;
            background-color: rgba(20, 20, 20, 0.7);
            border: 0;
            color: white;
            font-size: 2rem;
            z-index: 20;
            cursor: pointer;
            align-items: center;
            justify-content: center;
        }
        .carousel-arrow.left { left: 0; border-radius: 0 8px 8px 0; }
        .carousel-arrow.right { right: 0; border-radius: 8px 0 0 8px; }

        /* --- NOVAS ANIMAÇÕES --- */
        .media-card {
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
            position: relative; /* Garante que o z-index funcione corretamente */
        }
        .media-card:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 10px 30px rgba(0,0,0,0.7);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .carousel-section, .grid-page-container {
            animation: fadeIn 0.6s ease-out forwards;
        }

        .carousel-section {
            position: relative; /* Necessário para o z-index funcionar */
        }
        
        .carousel-section:hover {
            z-index: 5; /* Eleva a seção inteira para que o card expandido não seja cortado por seções vizinhas */
        }


        /* Animação do Modal */
        #details-modal {
            background-color: rgba(0,0,0,0.7);
            transition: opacity 0.3s ease-in-out;
        }
        #modal-content {
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out, width 0.3s ease-in-out, height 0.3s ease-in-out;
            transform: scale(0.9);
            opacity: 0;
        }
        #details-modal.show {
            opacity: 1;
        }
        #details-modal.show #modal-content {
            transform: scale(1);
            opacity: 1;
        }
        #details-modal:not(.show) {
            opacity: 0;
        }
        
        .nav-link.active {
            font-weight: 700;
        }

        /* Estilos da barra de pesquisa animada */
        #search-container.active #search-bar {
            width: 150px; /* Largura no mobile */
            opacity: 1;
            padding: 0.25rem 0.75rem; /* py-1 px-3 */
            border: 1px solid #4A5568; /* border-gray-600 */
        }

        @media (min-width: 640px) { /* sm breakpoint */
            #search-container.active #search-bar {
                width: 250px; /* Largura em telas maiores */
            }
        }
        
        /* Efeito de fade-in para imagens */
        .poster-img {
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        .poster-img.loaded {
            opacity: 1;
        }

        /* --- ESTILOS DOS FILTROS (SELECT) --- */
        .custom-select {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-color: #141414;
            border: 1px solid #6b7280; /* cinza-500 */
            color: white;
            padding: 0.5rem 2.5rem 0.5rem 1rem; /* py-2 pr-10 pl-4 */
            border-radius: 0.25rem; /* rounded-md */
            background-image: url("data:image/svg+xml;charset=UTF8,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2020%2020'%20fill='white'%3E%3Cpath%20fill-rule='evenodd'%20d='M5.293%207.293a1%201%200%20011.414%200L10%2010.586l3.293-3.293a1%201%200%20111.414%201.414l-4%204a1%201%200%2001-1.414%200l-4-4a1%201%200%20010-1.414z'%20clip-rule='evenodd'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.2em;
            font-weight: 500;
            cursor: pointer;
            transition: border-color 0.2s;
        }
        .custom-select:hover {
            border-color: white;
        }
        .custom-select:focus {
            outline: none;
            border-color: white;
            box-shadow: 0 0 0 2px #141414, 0 0 0 4px #E50914;
        }

        .player-season-select {
            background-color: #202020;
            border: 1px solid #4a5568;
            padding: 0.25rem 2.5rem 0.25rem 0.75rem; /* py-1 pr-10 pl-3 */
            font-size: 0.875rem; /* text-sm */
            font-weight: 600; /* font-semibold */
        }
        .player-season-select:hover {
            border-color: #a0aec0; /* gray-400 */
        }
        .player-season-select:focus {
             box-shadow: 0 0 0 2px #141414, 0 0 0 4px #E50914;
             border-color: white;
        }
        
        /* Estilos da tela de Abertura */
        #splash-screen {
            transition: opacity 0.7s ease-out;
        }
        
        /* --- ESTILOS DO PLAYER CUSTOMIZADO (CORRIGIDO) --- */
        #custom-player-container {
            position: relative;
            width: 100%;
            height: 100%; /* Modificado para ocupar a altura total no modo player */
            background-color: black;
        }
        #player-controls-overlay {
            position: absolute;
            inset: 0;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, transparent 40%, transparent 60%, rgba(0,0,0,0.7) 100%);
            pointer-events: none; /* O overlay em si NUNCA captura cliques, permitindo que passem para o iframe. */
        }
        #custom-player-container:hover #player-controls-overlay {
            opacity: 1; /* No hover, apenas tornamos o overlay visível. */
        }
        .player-control-btn {
            background-color: rgba(40, 40, 40, 0.7);
            border-radius: 9999px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: white;
            pointer-events: auto; /* CORREÇÃO: Isso faz com que APENAS os botões sejam clicáveis, e não o overlay inteiro. */
        }
        .player-control-btn:hover {
            background-color: rgba(60, 60, 60, 0.9);
        }

        /* --- ESTILOS DO PAINEL DE EPISÓDIOS DO PLAYER --- */
        #player-episode-panel {
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            width: 100%;
            max-width: 400px;
            background-color: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 20;
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
            overflow-y: auto;
        }
        #player-episode-panel.open {
            transform: translateX(0);
        }
        #player-episode-panel .episode-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        #player-episode-panel .episode-item.playing {
            background-color: #E50914;
            font-weight: bold;
        }

        /* --- ESTILOS DO PLAYER EM TELA CHEIA (MODIFICADO) --- */
        #details-modal.player-mode {
            /* Sobrescreve a centralização para permitir que o player preencha a tela */
            align-items: stretch;
            justify-content: stretch;
        }
        #modal-content.player-mode-content {
            /* Faz o contêiner do player preencher a tela */
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
            border-radius: 0;
            background-color: #000;
            overflow: hidden; /* Previne barras de rolagem na visualização do player */
        }

    </style>
</head>
<body class="text-white bg-netflix-main">

    <!-- Splash Screen de Abertura -->
    <div id="splash-screen" class="fixed inset-0 bg-black z-50 flex items-center justify-center">
        <video id="splash-video" class="absolute top-0 left-0 w-full h-full object-cover" src="https://i.imgur.com/mQfvVxg.mp4" autoplay muted playsinline></video>
        <button id="skip-intro" class="absolute bottom-10 right-10 z-20 bg-black bg-opacity-50 text-white px-4 py-2 rounded text-sm hover:bg-opacity-75">Pular Abertura</button>
    </div>

    <!-- Container Principal da Aplicação -->
    <div id="app-container" style="opacity: 0; transition: opacity 1s ease-in;">
        <!-- Cabeçalho Fixo -->
        <header class="fixed top-0 left-0 right-0 p-4 md:p-6 flex justify-between items-center z-30 transition-colors duration-300" id="main-header">
            <div class="flex items-center space-x-4 md:space-x-8">
                <h1 id="logo" class="text-2xl sm:text-3xl font-bold text-netflix-red uppercase tracking-wider cursor-pointer">FudidoFlix</h1>
                <nav id="main-nav" class="hidden md:flex items-center space-x-2 sm:space-x-6">
                    <a href="#" class="nav-link text-base sm:text-lg font-semibold hover:text-gray-300 active" data-page="discover">Início</a>
                    <a href="#" class="nav-link text-base sm:text-lg font-semibold hover:text-gray-300" data-page="tv">Séries</a>
                    <a href="#" class="nav-link text-base sm:text-lg font-semibold hover:text-gray-300" data-page="movie">Filmes</a>
                    <a href="#" class="nav-link text-base sm:text-lg font-semibold hover:text-gray-300" data-page="animes">Animes</a>
                    <a href="#" class="nav-link text-base sm:text-lg font-semibold hover:text-gray-300" data-page="my-list">Minha Lista</a>
                </nav>
            </div>
            <div id="search-container" class="relative flex items-center justify-end">
                <input id="search-bar" type="text" placeholder="Procurar..." 
                       class="w-0 p-0 border-transparent bg-black bg-opacity-70 text-white rounded-md focus:outline-none focus:ring-1 focus:ring-white transition-all duration-300 ease-in-out opacity-0">
                <button id="search-button" class="p-2 text-lg text-white">
                    <i class="fas fa-search"></i>
                </button>
            </div>
        </header>

        <!-- Área de Conteúdo Principal (será preenchida via JS) -->
        <main id="content-area" class="pt-24 px-4 md:px-10 pb-10">
            <!-- Conteúdo dinâmico será injetado aqui -->
        </main>
        <div id="infinite-scroll-loader" class="flex justify-center items-center h-20"></div>

    </div>

    <!-- Modal para exibir detalhes do filme/série -->
    <div id="details-modal" class="fixed inset-0 flex items-center justify-center z-50 hidden opacity-0">
        <div id="modal-content" class="bg-netflix-secondary rounded-lg w-11/12 max-w-4xl max-h-[90vh] overflow-y-auto relative shadow-2xl">
            <!-- Conteúdo do modal será injetado aqui -->
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- CONFIGURAÇÕES E ESTADO DA APLICAÇÃO ---
        const API_KEY = '04c35731a5ee918f014970082a0088b1';
        const API_BASE_URL = 'https://api.themoviedb.org/3';
        const IMG_BASE_URL = 'https://image.tmdb.org/t/p/original';
        const NO_POSTER_URL = 'https://placehold.co/500x750/202020/ffffff?text=Poster+Indisponível';

        const plusIcon = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v12m6-6H6"></path></svg>`;
        const checkIcon = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>`;

        let currentMediaData = null;
        let currentPage = 'discover';
        let gridPageNumber = 1;
        let isFetching = false;
        let currentGridType = null;
        let hasMorePages = true;
        let currentGenre = 'all';
        let currentSortBy = 'popularity.desc';
        
        let navigationId = 0;

        // --- SELEÇÃO DE ELEMENTOS DO DOM ---
        const contentArea = document.getElementById('content-area');
        const searchContainer = document.getElementById('search-container');
        const searchButton = document.getElementById('search-button');
        const searchBar = document.getElementById('search-bar');
        const mainNav = document.getElementById('main-nav');
        const modal = document.getElementById('details-modal');
        const modalContent = document.getElementById('modal-content');
        const header = document.getElementById('main-header');
        const logo = document.getElementById('logo');
        const infiniteScrollLoader = document.getElementById('infinite-scroll-loader');
        
        // --- FUNÇÕES DE API ---
        const getTodayDate = () => new Date().toISOString().split('T')[0];

        async function fetchAPI(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Erro de HTTP! status: ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error(`Falha ao buscar API: ${url}`, error);
                return null;
            }
        }
        
        const fetchTMDB = (endpoint) => {
            const separator = endpoint.includes('?') ? '&' : '?';
            const tmdbUrl = `${API_BASE_URL}${endpoint}${separator}api_key=${API_KEY}&language=pt-BR`;
            return fetchAPI(tmdbUrl);
        };
        
        async function searchMoviesByTitles(titles) {
            const searchPromises = titles.map(title => 
                fetchTMDB(`/search/movie?query=${encodeURIComponent(title)}&include_adult=false`)
            );
            const searchResults = await Promise.all(searchPromises);
            
            const foundMovies = [];
            searchResults.forEach(result => {
                if (result && result.results && result.results.length > 0) {
                    const movie = result.results[0];
                    if (!foundMovies.some(m => m.id === movie.id)) {
                        foundMovies.push(movie);
                    }
                }
            });
            return foundMovies;
        }

        async function searchSeriesByTitles(titles) {
            const searchPromises = titles.map(title => 
                fetchTMDB(`/search/tv?query=${encodeURIComponent(title)}`)
            );
            const searchResults = await Promise.all(searchPromises);
            
            const foundSeries = [];
            searchResults.forEach(result => {
                if (result && result.results && result.results.length > 0) {
                    const series = result.results[0];
                    if (!foundSeries.some(s => s.id === series.id)) {
                        foundSeries.push(series);
                    }
                }
            });
            return foundSeries;
        }

        // --- FUNÇÕES DE HISTÓRICO (localStorage) ---
        const getWatchedHistory = () => {
            try {
                const history = localStorage.getItem('fudidoFlixHistory');
                return history ? JSON.parse(history) : [];
            } catch (e) { return []; }
        };

        const updateWatchedHistoryCarousel = () => {
            const historyContainer = document.getElementById('watched-history-container');
            if (historyContainer) {
                const historyData = getWatchedHistory();
                if (historyData.length > 0) {
                    historyContainer.innerHTML = createCarousel('Últimos Assistidos', historyData, 'watched_history-carousel');
                } else {
                    historyContainer.innerHTML = ''; 
                }
            }
        };

        const saveToWatchedHistory = (mediaItem) => {
            if (!mediaItem || !mediaItem.id) return;
            let history = getWatchedHistory();
            history = history.filter(item => item.id !== mediaItem.id);
            history.unshift(mediaItem);
            const updatedHistory = history.slice(0, 10);
            localStorage.setItem('fudidoFlixHistory', JSON.stringify(updatedHistory));
            updateWatchedHistoryCarousel();
        };

        // --- FUNÇÕES DA MINHA LISTA (localStorage) ---
        const getMyList = () => {
            try {
                const list = localStorage.getItem('fudidoFlixMyList');
                return list ? JSON.parse(list) : [];
            } catch (e) { return []; }
        };

        const saveMyList = (list) => {
            localStorage.setItem('fudidoFlixMyList', JSON.stringify(list));
        };
        
        const isItemInMyList = (mediaId) => {
            const list = getMyList();
            return list.some(item => item.id === Number(mediaId));
        };

        const toggleMyList = (mediaItem) => {
            let list = getMyList();
            const mediaId = mediaItem.id;
            const itemIndex = list.findIndex(item => item.id === mediaId);

            if (itemIndex > -1) {
                list.splice(itemIndex, 1);
            } else {
                const itemToAdd = {
                    id: mediaItem.id,
                    poster_path: mediaItem.poster_path,
                    title: mediaItem.title,
                    name: mediaItem.name,
                    media_type: mediaItem.title ? 'movie' : 'tv'
                };
                list.unshift(itemToAdd);
            }
            saveMyList(list);
            return itemIndex === -1;
        };
        
        // --- FUNÇÕES DE RENDERIZAÇÃO ---
        const showLoading = (element) => {
            element.innerHTML = `<div class="flex justify-center items-center h-full py-10"><span class="loader"></span></div>`;
        };

        const showInfiniteScrollLoader = (show) => {
            infiniteScrollLoader.innerHTML = show ? '<span class="loader"></span>' : '';
        };
        
        const createMediaCard = (media, isGridItem = false) => {
            const title = media.title || media.name;
            const posterPath = media.poster_path ? `https://image.tmdb.org/t/p/w500${media.poster_path}` : NO_POSTER_URL;
            const mediaType = media.media_type || (media.title ? 'movie' : 'tv');
            
            const sizeClasses = isGridItem 
                ? 'w-full' 
                : 'flex-shrink-0 w-36 sm:w-40 md:w-48';

            return `
                <div class="media-card aspect-[2/3] ${sizeClasses} cursor-pointer group rounded-md overflow-hidden bg-gray-900" data-id="${media.id}" data-type="${mediaType}">
                    <img src="${posterPath}" alt="${title}" class="poster-img w-full h-full object-cover" loading="lazy" onload="this.classList.add('loaded')" onerror="this.onerror=null;this.src='${NO_POSTER_URL}'; this.classList.add('loaded');">
                    <div class="absolute inset-0 bg-gradient-to-t from-black via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex items-end p-2 sm:p-3">
                         <p class="text-white text-sm sm:text-base font-semibold truncate">${title}</p>
                    </div>
                </div>`;
        };

        const createCarousel = (title, items, carouselId) => {
            if (!items || items.length === 0) return '';
            
            const allItems = [...items, ...items];
            const cards = allItems.map(item => createMediaCard(item, false)).join('');

            return `
                <section class="mb-10 carousel-section opacity-0" data-original-item-count="${items.length}">
                    <h2 class="text-xl sm:text-2xl font-bold mb-4">${title}</h2>
                    <div class="carousel-container relative group">
                        <div id="${carouselId}" class="carousel flex items-start space-x-3 md:space-x-4 overflow-x-auto py-6 -my-6" style="scroll-behavior: auto;">
                            ${cards}
                        </div>
                        <button class="carousel-arrow left hidden group-hover:md:flex" data-direction="-1" data-carousel="${carouselId}"><i class="fas fa-chevron-left"></i></button>
                        <button class="carousel-arrow right hidden group-hover:md:flex" data-direction="1" data-carousel="${carouselId}"><i class="fas fa-chevron-right"></i></button>
                    </div>
                </section>`;
        };
        
        // --- LÓGICA DE RENDERIZAÇÃO DE PÁGINAS ---

        const renderDiscoverPage = async () => {
            const callNavigationId = navigationId; 
            showLoading(contentArea);

            const combineAndSort = (movies, tv) => {
                const typedMovies = (movies?.results || []).map(m => ({ ...m, media_type: 'movie' }));
                const typedTv = (tv?.results || []).map(t => ({ ...t, media_type: 'tv' }));
                return [...typedMovies, ...typedTv].sort((a, b) => b.popularity - a.popularity);
            };

            const categories = [ 
                { id: 'trending', title: 'Em Alta', fetcher: async () => { const [p1, p2] = await Promise.all([fetchTMDB('/trending/all/week?page=1'), fetchTMDB('/trending/all/week?page=2')]); return [...(p1?.results || []), ...(p2?.results || [])].filter(Boolean); } }, 
                { id: 'watched_history', title: 'Últimos Assistidos', fetcher: () => Promise.resolve(getWatchedHistory()) },
                { id: 'acclaimed_tv', title: 'Séries Aclamadas pela Crítica', fetcher: async () => (await fetchTMDB('/tv/top_rated'))?.results || [] }, 
                { id: 'popular_movies', title: 'Filmes Populares', fetcher: async () => { const [p1, p2] = await Promise.all([fetchTMDB('/movie/popular?page=1'), fetchTMDB('/movie/popular?page=2')]); return [...(p1?.results || []), ...(p2?.results || [])].filter(Boolean); } }, 
                { id: 'popular_tv', title: 'Séries Populares', fetcher: async () => { const [p1, p2] = await Promise.all([fetchTMDB('/tv/popular?page=1'), fetchTMDB('/tv/popular?page=2')]); return [...(p1?.results || []), ...(p2?.results || [])].filter(Boolean); } }, 
                { id: 'horror_thriller', title: 'Terror e Suspense', fetcher: async () => { const [movies, tv] = await Promise.all([ fetchTMDB('/discover/movie?with_genres=27,53&sort_by=popularity.desc'), fetchTMDB('/discover/tv?with_genres=9648&with_keywords=9717&sort_by=popularity.desc') ]); return combineAndSort(movies, tv); } }, 
                { id: 'award_winners', title: 'Vencedores do Oscar & Emmy', fetcher: async () => { 
                    const [oscarMovies, emmyTvs] = await Promise.all([
                        fetchTMDB('/discover/movie?with_keywords=9954&sort_by=vote_average.desc&vote_count.gte=10'),
                        fetchTMDB('/discover/tv?with_keywords=11246&sort_by=vote_average.desc&vote_count.gte=10')
                    ]);
                    return combineAndSort(oscarMovies, emmyTvs);
                } },
                { id: 'anime', title: 'Animes', fetcher: async () => (await fetchTMDB('/discover/tv?with_genres=16&with_original_language=ja&sort_by=popularity.desc&without_keywords=291485'))?.results || [] },
                { id: 'netflix', title: 'Originais e Exclusivos Netflix', fetcher: async () => {
                    const [movies, tv] = await Promise.all([
                        fetchTMDB('/discover/movie?watch_region=BR&with_watch_providers=8&with_networks=213&sort_by=popularity.desc'),
                        fetchTMDB('/discover/tv?watch_region=BR&with_watch_providers=8&with_networks=213&sort_by=popularity.desc')
                    ]);
                    return combineAndSort(movies, tv);
                }},
                { id: 'prime_video', title: 'Originais e Exclusivos Prime Video', fetcher: async () => {
                    const [movies, tv] = await Promise.all([
                        fetchTMDB('/discover/movie?watch_region=BR&with_watch_providers=119&with_networks=1024&sort_by=popularity.desc'),
                        fetchTMDB('/discover/tv?watch_region=BR&with_watch_providers=119&with_networks=1024&sort_by=popularity.desc')
                    ]);
                    return combineAndSort(movies, tv);
                }},
                { id: 'max', title: 'Originais e Exclusivos Max', fetcher: async () => {
                    const [movies, tv] = await Promise.all([
                        fetchTMDB('/discover/movie?watch_region=BR&with_watch_providers=1899&sort_by=popularity.desc'),
                        fetchTMDB('/discover/tv?watch_region=BR&with_watch_providers=1899&sort_by=popularity.desc')
                    ]);
                    return combineAndSort(movies, tv);
                }},
                { id: 'paramount_plus', title: 'Originais e Exclusivos Paramount+', fetcher: async () => {
                    const [movies, tv] = await Promise.all([
                        fetchTMDB('/discover/movie?watch_region=BR&with_watch_providers=531&with_networks=4330&sort_by=popularity.desc'),
                        fetchTMDB('/discover/tv?watch_region=BR&with_watch_providers=531&with_networks=4330&sort_by=popularity.desc')
                    ]);
                    return combineAndSort(movies, tv);
                }},
                { id: 'globoplay', title: 'Originais e Exclusivos Globoplay', fetcher: async () => {
                    const [movies, tv] = await Promise.all([
                        fetchTMDB('/discover/movie?watch_region=BR&with_watch_providers=307&with_networks=2554&sort_by=popularity.desc'),
                        fetchTMDB('/discover/tv?watch_region=BR&with_watch_providers=307&sort_by=popularity.desc')
                    ]);
                    return combineAndSort(movies, tv);
                }},
                { id: 'disney_plus', title: 'Originais e Exclusivos Disney+', fetcher: async () => {
                    const [movies, tv] = await Promise.all([
                        fetchTMDB('/discover/movie?watch_region=BR&with_watch_providers=337&with_networks=2739&sort_by=popularity.desc'),
                        fetchTMDB('/discover/tv?watch_region=BR&with_watch_providers=337&with_networks=2739&sort_by=popularity.desc')
                    ]);
                    return combineAndSort(movies, tv);
                }},
                { id: 'apple_tv_plus', title: 'Originais e Exclusivos Apple TV+', fetcher: async () => {
                    const [movies, tv] = await Promise.all([
                        fetchTMDB('/discover/movie?watch_region=BR&with_watch_providers=350&with_networks=2552&sort_by=popularity.desc'),
                        fetchTMDB('/discover/tv?watch_region=BR&with_watch_providers=350&with_networks=2552&sort_by=popularity.desc')
                    ]);
                    return combineAndSort(movies, tv);
                }},
                { id: 'brazilian_movies', title: 'Filmes Brasileiros', fetcher: async () => {
                    const data = await fetchTMDB('/discover/movie?with_origin_country=BR&sort_by=popularity.desc&vote_count.gte=25');
                    return data?.results || [];
                }}
            ];
            
            const trendingData = await categories.find(c => c.id === 'trending').fetcher();
            if (callNavigationId !== navigationId) return;

            let heroHtml = '';
            if (trendingData && trendingData.length > 0) {
                const heroMedia = trendingData[Math.floor(Math.random() * trendingData.length)];
                const title = heroMedia.title || heroMedia.name;
                const backdrop = heroMedia.backdrop_path ? `${IMG_BASE_URL}${heroMedia.backdrop_path}` : '';

                const ratingsData = await fetchTMDB(`/${heroMedia.media_type}/${heroMedia.id}/${heroMedia.media_type === 'movie' ? 'release_dates' : 'content_ratings'}`);
                if (callNavigationId !== navigationId) return; 
                
                let rating = 'N/A';
                if (heroMedia.media_type === 'movie' && ratingsData.results) {
                    const brRating = ratingsData.results.find(r => r.iso_3166_1 === 'BR');
                    if (brRating && brRating.release_dates[0]) rating = brRating.release_dates[0].certification;
                } else if (heroMedia.media_type === 'tv' && ratingsData.results) {
                    const brRating = ratingsData.results.find(r => r.iso_3166_1 === 'BR');
                    if (brRating) rating = brRating.rating;
                }
                if (!rating || rating === '') rating = "N/A";

                heroHtml = `
                <div class="h-[80vh] -mx-4 md:-mx-10 -mt-24 mb-10 bg-cover bg-center bg-no-repeat relative flex items-center" style="background-image: url('${backdrop}');">
                    <div class="w-full h-full absolute inset-0 bg-gradient-to-r from-black via-black/70 to-transparent"></div>
                    <div class="relative z-10 p-4 md:p-10 text-white w-full md:w-1/2 lg:w-2/5">
                        <p class="font-bold tracking-widest text-lg">${heroMedia.media_type === 'tv' ? 'SÉRIE' : 'FILME'}</p>
                        <h2 class="text-4xl md:text-6xl font-bold my-4">${title}</h2>
                        <p class="max-w-xl mt-4 text-base md:text-lg hidden md:block">${heroMedia.overview.substring(0, 150)}...</p>
                        <div class="flex items-center space-x-3 mt-6">
                            <button class="hero-play-btn flex items-center justify-center gap-2 px-6 py-2 rounded font-semibold bg-white text-black text-lg hover:bg-gray-200" data-id="${heroMedia.id}" data-type="${heroMedia.media_type}">
                                <i class="fas fa-play"></i> Assistir
                            </button>
                            <button class="hero-info-btn flex items-center justify-center gap-2 px-6 py-2 rounded font-semibold bg-gray-500 bg-opacity-70 text-white text-lg hover:bg-gray-600" data-id="${heroMedia.id}" data-type="${heroMedia.media_type}">
                                <i class="fas fa-info-circle"></i> Mais Informações
                            </button>
                        </div>
                    </div>
                    <div class="absolute right-4 bottom-4 z-10 flex items-center space-x-2">
                        <span class="border-l-4 border-gray-500 pl-2 text-lg bg-black bg-opacity-50 p-2">${rating}</span>
                    </div>
                </div>`;
            }
            contentArea.innerHTML = heroHtml;
            
            for (const category of categories) {
                const items = (category.id === 'trending') ? trendingData : await category.fetcher();
                if (callNavigationId !== navigationId) return;

                if(items && items.length > 0) {
                    const carouselHtml = createCarousel(category.title, items, `${category.id}-carousel`);
                    const container = document.createElement('div');
                    if (category.id === 'watched_history') {
                        container.id = 'watched-history-container';
                    }
                    container.innerHTML = carouselHtml;
                    contentArea.appendChild(container);
                } else if (category.id === 'watched_history') {
                    const container = document.createElement('div');
                    container.id = 'watched-history-container';
                    contentArea.appendChild(container);
                }
            }
            contentArea.insertAdjacentHTML('beforeend', `<p class="text-center text-gray-500 py-8">Você chegou ao fim!</p>`);
        };

        const renderGridPage = async (type, page = 1) => {
            const callNavigationId = navigationId;
            if (isFetching) return;
            isFetching = true;
            page === 1 ? showLoading(contentArea) : showInfiniteScrollLoader(true);

            if (page === 1) {
                let title = '';
                if (type === 'movie') title = 'Filmes';
                else if (type === 'tv') title = 'Séries';
                else if (type === 'animes') title = 'Animes';

                const movieBaseFilters = [
                    { value: 'all', name: 'Gêneros' }, { value: 'g-28', name: 'Ação' },
                    { value: 'c-BR', name: 'Brasileiros' }, { value: 'rd-1980-12-31', name: 'Clássicos' },
                    { value: 'k-9716', name: 'Stand-up' }, { value: 'g-35', name: 'Comédias' },
                    { value: 'g-99', name: 'Documentários' }, { value: 'g-18', name: 'Drama' }, 
                    { value: 'g-14', name: 'Fantasia' }, { value: 'g-878', name: 'Ficção Científica' },
                    { value: 'g-10402', name: 'Música e Musicais' }, { value: 'g-80', name: 'Policial' }, 
                    { value: 'g-10749', name: 'Romance' }, { value: 'g-53', name: 'Suspense' }, 
                    { value: 'g-27', name: 'Terror' }
                ];
                
                const tvBaseFilters = [
                    { value: 'all', name: 'Gêneros' }, 
                    { value: 'g-10759', name: 'Ação e Aventura' },
                    { value: 'g-16', name: 'Animação' }, 
                    { value: 'c-BR', name: 'Brasileiras' },
                    { value: 'fd-1990-12-31', name: 'Clássicos (até 1990)' }, 
                    { value: 'g-35', name: 'Comédia' },
                    { value: 'g-80', name: 'Crime' }, 
                    { value: 'g-99', name: 'Documentário' },
                    { value: 'g-18', name: 'Drama' }, 
                    { value: 'g-10765', name: 'Ficção Científica e Fantasia' }, 
                    { value: 'g-9648', name: 'Mistério' }, 
                    { value: 'g-10764', name: 'Reality Show' },
                    { value: 'k-9716', name: 'Stand-up' },
                    { value: 'g-10767', name: 'Talk Show' }
                ];

                const movieSpecificFilters = [ { value: 'p-2|3', name: 'Disney e Pixar' }, { value: 'k-oscar-list', name: 'Premiados (Oscar)' } ];
                const tvSpecificFilters = [ { value: 'k-emmy-list', name: 'Premiados (Emmy)' } ];
                
                const streamingFilters = [
                    { value: 'separator', name: '──────────' }, { value: 's-8,213', name: 'Netflix' },
                    { value: 's-119,1024', name: 'Prime Video' }, { value: 's-1899', name: 'Max' },
                    { value: 's-531,4330', name: 'Paramount+' }, { value: 's-307', name: 'Globo Play' },
                    { value: 's-337,2739', name: 'Disney+' }, { value: 's-350,2552', name: 'Apple TV+' },
                ];
                
                let finalFilters = [];
                if (type === 'movie') finalFilters = [...movieBaseFilters, ...movieSpecificFilters, ...streamingFilters];
                else if (type === 'tv') finalFilters = [...tvBaseFilters, ...tvSpecificFilters, ...streamingFilters];

                const dateSortValue = (type === 'movie') ? 'primary_release_date.desc' : 'first_air_date.desc';
                
                const filterControls = `
                    <div id="filter-controls" class="flex flex-wrap items-center gap-4">
                        ${(type === 'movie' || type === 'tv') ? `
                        <select id="genre-filter" class="custom-select">
                            ${finalFilters.map(filter => {
                                if (filter.value === 'separator') return `<option disabled>${filter.name}</option>`;
                                return `<option value="${filter.value}" ${currentGenre === filter.value ? 'selected' : ''}>${filter.name}</option>`;
                            }).join('')}
                        </select>
                        ` : ''}
                        <select id="sort-by-filter" class="custom-select">
                            <option value="popularity.desc" ${currentSortBy === 'popularity.desc' ? 'selected' : ''}>Popularidade</option>
                            <option value="${dateSortValue}" ${currentSortBy === dateSortValue ? 'selected' : ''}>Lançamento</option>
                            <option value="vote_average.desc" ${currentSortBy === 'vote_average.desc' ? 'selected' : ''}>Avaliações</option>
                        </select>
                    </div>`;

                contentArea.innerHTML = `
                    <div class="grid-page-container opacity-0">
                        <div class="flex flex-wrap justify-between items-center gap-4 mb-6">
                            <h2 class="text-2xl sm:text-3xl font-bold">${title}</h2>
                            ${filterControls}
                        </div>
                        <div id="media-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 2xl:grid-cols-7 gap-4"></div>
                    </div>`;

                const genreFilter = document.getElementById('genre-filter');
                if (genreFilter) genreFilter.addEventListener('change', (e) => { currentGenre = e.target.value; navigateTo(currentPage); });
                document.getElementById('sort-by-filter').addEventListener('change', (e) => { currentSortBy = e.target.value; navigateTo(currentPage); });
            }
            
            let data = { results: [], page: page, total_pages: page };

            const isAwardFilter = currentGenre === 'k-oscar-list' || currentGenre === 'k-emmy-list';

            if (isAwardFilter) {
                const batchSize = 10;
                let titleList = [];
                let searchFunction;

                if (currentGenre === 'k-oscar-list') {
                    titleList = ["Duna: Parte Dois", "Ainda Estou Aqui", "Anora", "The Brutalist", "Conclave", "Emilia Pérez", "Gladiador 2", "Nickel Boys", "Sing Sing", "Wicked", "Oppenheimer", "Ficção Americana", "Anatomia de uma Queda", "Barbie", "Os Rejeitados", "Assassinos da Lua das Flores", "Maestro", "Vidas Pastadas", "Pobres Criaturas", "Zona de Interesse", "Tudo em Todo o Lugar ao Mesmo Tempo", "Nada de Novo no Front", "Avatar: O Caminho da Água", "Os Banshees de Inisherin", "Elvis", "Os Fabelmans", "TÁR", "Top Gun: Maverick", "Triângulo da Tristeza", "Entre Mulheres", "No Ritmo do Coração", "Belfast", "Não Olhe Para Cima", "Drive My Car", "Duna", "King Richard: Criando Campeãs", "Licorice Pizza", "O Beco do Pesadelo", "Ataque dos Cães", "Amor, Sublime Amor", "Nomadland", "Meu Pai", "Judas e o Messias Negro", "Mank", "Minari: Em Busca da Felicidade", "Bela Vingança", "O Som do Silêncio", "Os 7 de Chicago", "Parasita", "1917", "Ford vs Ferrari", "O Irlandês", "Jojo Rabbit", "Coringa", "Adoráveis Mulheres", "História de Um Casamento", "Era Uma Vez Em... Hollywood", "Green Book: O Guia", "Pantera Negra", "Infiltrado na Klan", "Bohemian Rhapsody", "A Favorita", "Roma", "Nasce uma Estrela", "Vice", "A Forma da Água", "Me Chame Pelo Seu Nome", "O Destino de uma Nação", "Dunkirk", "Corra!", "Lady Bird: A Hora de Voar", "Trama Fantasma", "The Post: A Guerra Secreta", "Três Anúncios Para um Crime", "Moonlight: Sob a Luz do Luar", "A Chegada", "Um Limite Entre Nós", "Até o Último Homem", "A Qualquer Custo", "Estrelas Além do Tempo", "La La Land: Cantando Estações", "Lion: Uma Jornada Para Casa", "Manchester à Beira-Mar", "Spotlight: Segredos Revelados", "A Grande Aposta", "Ponte dos Espiões", "Brooklyn", "Mad Max: Estrada da Fúria", "Perdido em Marte", "O Regresso", "O Quarto de Jack", "Birdman ou (A Inesperada Virtude da Ignorância)", "Boyhood: Da Infância à Juventude", "O Grande Hotel Budapeste", "O Jogo da Imitação", "A Teoria de Tudo", "Selma: Uma Luta Pela Igualdade", "Sniper Americano", "Whiplash: Em Busca da Perfeição", "12 Anos de Escravidão", "Trapaça", "Gravidade", "O Lobo de Wall Street", "Clube de Compras Dallas", "Ela", "Capitão Phillips", "Nebraska", "Philomena", "Argo", "Amor", "Indomável Sonhadora", "Django Livre", "Os Miseráveis", "As Aventuras de Pi", "Lincoln", "O Lado Bom da Vida", "A Hora Mais Escura", "O Artista", "Cavalo de Guerra", "O Homem que Mudou o Jogo", "Tão Forte e Tão Perto", "Histórias Cruzadas", "A Invenção de Hugo Cabret", "Meia-Noite em Paris", "Os Descendentes", "A Árvore da Vida", "O Discurso do Rei", "127 Horas", "Cisne Negro", "A Origem", "O Vencedor", "Minhas Mães e Meu Pai", "A Rede Social", "Toy Story 3", "Bravura Indômita", "Inverno da Alma", "Guerra ao Terror", "Avatar", "Um Sonho Possível", "Distrito 9", "Educação", "Bastardos Inglórios", "Um Homem Sério", "Preciosa: Uma História de Esperança", "Up: Altas Aventuras", "Amor Sem Escalas", "Quem Quer Ser Um Milionário?", "O Leitor", "Frost/Nixon", "O Curioso Caso de Benjamin Button", "Milk - A Voz da Igualdade", "Onde os Fracos Não Têm Vez", "Desejo e Reparação", "Juno", "Conduta de Risco", "Sangue Negro", "Os Infiltrados", "Babel", "Cartas de Iwo Jima", "Pequena Miss Sunshine", "A Rainha", "Crash - No Limite", "O Segredo de Brokeback Mountain", "Capote", "Boa Noite, e Boa Sorte", "Munique", "Menina de Ouro", "O Aviador", "Em Busca da Terra do Nunca", "Ray", "Sideways - Entre Umas e Outras", "O Senhor dos Anéis: O Retorno do Rei", "Encontros e Desencontros", "Mestre dos Mares - O Lado Mais Distante do Mundo", "Sobre Meninos e Lobos", "Seabiscuit - Alma de Herói", "Chicago", "Gangues de Nova York", "As Horas", "O Senhor dos Anéis: As Duas Torres", "O Pianista", "Uma Mente Brilhante", "Assassinato em Gosford Park", "Entre Quatro Paredes", "O Senhor dos Anéis: A Sociedade do Anel", "Moulin Rouge - Amor em Vermelho", "Gladiador", "Chocolate", "O Tigre e o Dragão", "Erin Brockovich - Uma Mulher de Talento", "Traffic", "Beleza Americana", "Regras da Vida", "À Espera de um Milagre", "O Informante", "O Sexto Sentido"];
                    searchFunction = searchMoviesByTitles;
                } else if (currentGenre === 'k-emmy-list') {
                    titleList = [ "Succession", "The Crown", "Game of Thrones", "The Handmaid's Tale", "Breaking Bad", "Homeland", "Mad Men", "24", "The Sopranos", "The West Wing", "Law & Order", "NYPD Blue", "ER", "The X-Files", "The Practice", "The Bear", "Ted Lasso", "Schitt's Creek", "Fleabag", "The Marvelous Mrs. Maisel", "Veep", "Modern Family", "30 Rock", "The Office", "Everybody Loves Raymond", "Arrested Development", "Friends", "Sex and the City", "Ally McBeal", "Frasier", "Seinfeld", "The Larry Sanders Show", "Murphy Brown", "Cheers", "The Golden Girls", "The Cosby Show", "Barney Miller", "Taxi", "All in the Family", "The Mary Tyler Moore Show", "M*A*S*H", "Get Smart", "Hill Street Blues", "The Queen's Gambit", "Watchmen", "Chernobyl", "When They See Us", "The People v. O. J. Simpson: American Crime Story", "Big Little Lies", "Ozark", "Better Call Saul", "This Is Us", "Stranger Things", "Westworld", "The Mandalorian", "The White Lotus", "Hacks", "Only Murders in the Building", "Abbott Elementary" ];
                    titleList = [...new Set(titleList)]; // Remove duplicates
                    searchFunction = searchSeriesByTitles;
                }
                
                const startIndex = (page - 1) * batchSize;
                const endIndex = page * batchSize;
                const titlesToFetch = titleList.slice(startIndex, endIndex);

                if (titlesToFetch.length > 0) {
                    const foundMedia = await searchFunction(titlesToFetch);
                    data.results = foundMedia;
                    data.total_pages = Math.ceil(titleList.length / batchSize);
                } else {
                    hasMorePages = false;
                }
            } else {
                const endpointType = type === 'animes' ? 'tv' : type;
                let endpoint = `/discover/${endpointType}?page=${page}&sort_by=${currentSortBy}`;
                const today = getTodayDate();
                
                if (endpointType === 'tv') endpoint += `&first_air_date.lte=${today}`;
                else if (endpointType === 'movie') endpoint += `&primary_release_date.lte=${today}`;

                if (type === 'animes') {
                    endpoint += `&with_genres=16&with_original_language=ja&without_keywords=291485&vote_count.gte=25`;
                } else {
                    let voteCountParam = '&vote_count.gte=50';
                    if (currentGenre !== 'all') {
                        const parts = currentGenre.split('-');
                        const prefix = parts[0];
                        const value = parts.slice(1).join('-');

                        switch (prefix) {
                            case 'g': endpoint += `&with_genres=${value}`; break;
                            case 'c': endpoint += `&with_origin_country=${value}`; break;
                            case 'k': 
                                endpoint += `&with_keywords=${value}`; 
                                if (value === '9716') { // stand-up
                                    endpoint += '&without_genres=16'; // Exclui animes
                                    voteCountParam = '&vote_count.gte=10';
                                }
                                break;
                            case 'p': endpoint += `&with_companies=${value}`; break;
                            case 'rd': endpoint += `&primary_release_date.lte=${value}`; break;
                            case 'fd': endpoint += `&first_air_date.lte=${value}`; break;
                            case 'rt': endpoint += `&with_runtime.lte=${value}`; break;
                            case 's':
                                const [provider, network] = value.split(',');
                                endpoint += `&watch_region=BR&with_watch_providers=${provider}`;
                                if (network) endpoint += `&with_networks=${network}`;
                                break;
                        }
                    }
                    endpoint += voteCountParam;
                }
                const apiData = await fetchTMDB(endpoint);
                if (apiData) data = apiData;
            }

            if (callNavigationId !== navigationId) {
                isFetching = false;
                showInfiniteScrollLoader(false);
                return;
            }

            if (data && data.results && data.results.length > 0) {
                const grid = document.getElementById('media-grid');
                if (grid) {
                    const cardsHtml = data.results.map(item => createMediaCard(item, true)).join('');
                    grid.insertAdjacentHTML('beforeend', cardsHtml);
                }
            } else if (page === 1) {
                const container = document.querySelector('.grid-page-container');
                if (container) {
                     const grid = document.getElementById('media-grid');
                     if(grid) grid.remove(); 
                     container.insertAdjacentHTML('beforeend', `<p class="text-center text-gray-400 py-10 text-xl">Nenhum resultado encontrado.</p>`);
                }
            }
            
            hasMorePages = data && data.page < data.total_pages;

            if (!hasMorePages) {
                const hasAnyContent = document.querySelector('#media-grid .media-card');
                if (page > 1 || hasAnyContent) { 
                    infiniteScrollLoader.innerHTML = `<p class="text-center text-gray-500 py-8">Você chegou ao fim!</p>`;
                } else {
                    infiniteScrollLoader.innerHTML = '';
                }
            } else {
                 showInfiniteScrollLoader(false);
            }
            
            isFetching = false;
        };

        const renderMyListPage = () => {
            const callNavigationId = navigationId;
            showLoading(contentArea);
            
            const myListItems = getMyList();
            
            if (callNavigationId !== navigationId) return;

            if (myListItems.length === 0) {
                contentArea.innerHTML = `
                    <div class="grid-page-container opacity-0 text-center py-20">
                        <h2 class="text-3xl font-bold mb-4">Minha Lista</h2>
                        <p class="text-xl text-gray-400">A sua lista está vazia.</p>
                        <p class="mt-2 text-gray-500">Adicione filmes e séries para vê-los aqui.</p>
                    </div>`;
                return;
            }

            const cardsHtml = myListItems.map(item => createMediaCard(item, true)).join('');

            contentArea.innerHTML = `
                <div class="grid-page-container opacity-0">
                    <div class="flex justify-between items-center mb-6">
                        <h2 class="text-2xl sm:text-3xl font-bold">Minha Lista</h2>
                    </div>
                    <div id="media-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 2xl:grid-cols-7 gap-4">
                        ${cardsHtml}
                    </div>
                </div>`;
        };
        
        const renderSearchResults = async (query) => {
            const callNavigationId = navigationId;
            showLoading(contentArea);
            const results = await fetchTMDB(`/search/multi?query=${encodeURIComponent(query)}`);
            
            if (callNavigationId !== navigationId) return;

            if (results && results.results) {
                const validResults = results.results.filter(r => (r.media_type === 'movie' || r.media_type === 'tv') && r.poster_path);
                if (validResults.length > 0) {
                    contentArea.innerHTML = createCarousel(`Resultados para "${query}"`, validResults, 'search-carousel');
                } else {
                    contentArea.innerHTML = `<p class="text-center text-gray-400 py-10 text-xl">Nenhum resultado encontrado para "${query}".</p>`;
                }
            } else {
                contentArea.innerHTML = `<p class="text-center text-gray-400 py-10 text-xl">Nenhum resultado encontrado.</p>`;
            }
        };

        // --- LÓGICA DE NAVEGAÇÃO ---
        const navigateTo = (page) => {
            navigationId++;
            
            if (page !== 'search') {
                searchBar.value = '';
                searchContainer.classList.remove('active');
            }

            if (currentPage !== page) {
                currentGenre = 'all';
                currentSortBy = 'popularity.desc';
            }

            currentPage = page;
            gridPageNumber = 1;
            hasMorePages = true;
            isFetching = false;

            contentArea.innerHTML = '';
            window.scrollTo(0, 0);
            window.removeEventListener('scroll', handleInfiniteScroll);
            showInfiniteScrollLoader(false);

            document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
            const activeLink = document.querySelector(`.nav-link[data-page="${page}"]`);
            if (activeLink) activeLink.classList.add('active');

            if (page === 'discover') {
                renderDiscoverPage();
            } else if (page === 'my-list') {
                renderMyListPage();
            } else if (page === 'search') {
                contentArea.innerHTML = `<p class="text-center text-gray-400 py-10 text-xl">Comece a digitar para pesquisar.</p>`;
            } else {
                currentGridType = page;
                renderGridPage(page);
                window.addEventListener('scroll', handleInfiniteScroll);
            }
        };

        const handleInfiniteScroll = () => {
            if (hasMorePages && window.innerHeight + window.scrollY >= document.documentElement.scrollHeight - 500 && !isFetching) {
                gridPageNumber++;
                renderGridPage(currentGridType, gridPageNumber);
            }
        };
        
        // --- MODAL, PLAYER E EVENT LISTENERS ---
        const showModal = () => { 
            document.body.style.overflow = 'hidden';
            modal.classList.remove('hidden'); 
            setTimeout(() => modal.classList.add('show'), 10); 
        };
        const hideModal = () => { 
            document.body.style.overflow = '';
            modal.classList.remove('show'); 
            modal.classList.remove('player-mode');
            modalContent.classList.remove('player-mode-content');
            setTimeout(() => { modal.classList.add('hidden'); modalContent.innerHTML = ''; currentMediaData = null; }, 300); 
        };
        const smoothScrollTo = (element, to, duration, callback) => { const start = element.scrollLeft; const change = to - start; let startTime = null; const easeInOutQuad = (t, b, c, d) => { t /= d / 2; if (t < 1) return c / 2 * t * t + b; t--; return -c / 2 * (t * (t - 2) - 1) + b; }; const animateScroll = (currentTime) => { if (startTime === null) startTime = currentTime; const timeElapsed = currentTime - startTime; element.scrollLeft = easeInOutQuad(timeElapsed, start, change, duration); if (timeElapsed < duration) { requestAnimationFrame(animateScroll); } else { element.scrollLeft = to; if (callback) callback(); } }; requestAnimationFrame(animateScroll); };
        
        const renderEpisodeList = async (tvId, seasonNumber) => {
            const container = document.getElementById('episode-list-container');
            showLoading(container);
            const seasonDetails = await fetchTMDB(`/tv/${tvId}/season/${seasonNumber}`);
            
            if (seasonDetails && seasonDetails.episodes) {
                container.innerHTML = `
                    <div class="border-t border-gray-700 pt-4 mt-4">
                        ${seasonDetails.episodes.map((ep, index) => `
                            <div class="episode-item flex items-center gap-4 p-2 rounded-lg hover:bg-gray-800 cursor-pointer" data-season-number="${seasonNumber}" data-episode-number="${ep.episode_number}">
                                <span class="text-xl text-gray-400 font-bold w-4 text-center">${index + 1}</span>
                                <img src="${ep.still_path ? `https://image.tmdb.org/t/p/w200${ep.still_path}` : NO_POSTER_URL}" alt="${ep.name}" class="w-32 h-20 object-cover rounded-md">
                                <div class="flex-1">
                                    <div class="flex justify-between items-center">
                                        <h4 class="font-bold text-base">${ep.name}</h4>
                                        <span class="text-sm text-gray-400">${ep.runtime || 0}min</span>
                                    </div>
                                    <p class="text-sm text-gray-400 mt-1">${ep.overview.substring(0, 150)}${ep.overview.length > 150 ? '...' : ''}</p>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            } else {
                container.innerHTML = `<p class="text-gray-400">Não foi possível carregar os episódios.</p>`;
            }
        };

        const renderDetailsModal = async (mediaId, mediaType) => {
            modal.classList.remove('player-mode');
            modalContent.classList.remove('player-mode-content');
            
            showModal(); 
            showLoading(modalContent); 
            
            const [details, credits, keywordsData, ratingsData, videosData, recommendationsData] = await Promise.all([
                fetchTMDB(`/${mediaType}/${mediaId}`),
                fetchTMDB(`/${mediaType}/${mediaId}/credits`),
                fetchTMDB(`/${mediaType}/${mediaId}/keywords`),
                fetchTMDB(`/${mediaType}/${mediaId}/${mediaType === 'movie' ? 'release_dates' : 'content_ratings'}`),
                fetchTMDB(`/${mediaType}/${mediaId}/videos`),
                fetchTMDB(`/${mediaType}/${mediaId}/similar`)
            ]);

            if (!details) { hideModal(); return; }
            currentMediaData = details; 

            const title = details.title || details.name;
            const backdropPath = details.backdrop_path ? `${IMG_BASE_URL}${details.backdrop_path}` : '';
            const overview = details.overview;
            const year = (details.release_date || details.first_air_date || '').substring(0, 4);
            const genres = details.genres.map(g => g.name).join(', ');
            const cast = credits.cast.slice(0, 4).map(c => c.name).join(', ');
            const keywords = (keywordsData.keywords || keywordsData.results || []).slice(0, 3).map(k => k.name).join(', ');

            let runtimeText = '';
            if (mediaType === 'movie' && details.runtime) {
                const hours = Math.floor(details.runtime / 60);
                const minutes = details.runtime % 60;
                if (hours > 0) {
                    runtimeText = `${hours}h ${minutes}min`;
                } else {
                    runtimeText = `${minutes}min`;
                }
            } else if (mediaType === 'tv' && details.episode_run_time && details.episode_run_time.length > 0) {
                runtimeText = `${details.episode_run_time[0]}min / ep.`;
            }
            
            let rating = '';
            if (mediaType === 'movie' && ratingsData.results) {
                const brRating = ratingsData.results.find(r => r.iso_3166_1 === 'BR');
                if (brRating && brRating.release_dates[0]) rating = brRating.release_dates[0].certification;
            } else if (mediaType === 'tv' && ratingsData.results) {
                const brRating = ratingsData.results.find(r => r.iso_3166_1 === 'BR');
                if (brRating) rating = brRating.rating;
            }
            if (!rating) rating = "N/A";

            const trailer = videosData.results.find(v => v.site === 'YouTube' && v.type === 'Trailer');
            let trailerButtonHtml = '';
            if (trailer) {
                trailerButtonHtml = `
                    <button class="play-trailer-btn flex items-center justify-center gap-2 px-6 py-2 rounded font-semibold bg-gray-500 bg-opacity-70 text-white text-lg hover:bg-gray-600" data-trailer-key="${trailer.key}">
                        <i class="fas fa-film"></i> Trailer
                    </button>
                `;
            }

            const isInList = isItemInMyList(mediaId);
            const listButtonContent = isInList ? checkIcon : plusIcon;
            const listButtonTitle = isInList ? 'Remover da Minha Lista' : 'Adicionar à Minha Lista';

            const listButtonHtml = `
                <button id="add-to-list-btn" title="${listButtonTitle}" class="flex items-center justify-center w-12 h-12 rounded-full border-2 border-gray-400 bg-black bg-opacity-50 text-gray-300 hover:border-white hover:text-white transition">
                    ${listButtonContent}
                </button>`;

            let recommendationsHtml = '';
            if(recommendationsData && recommendationsData.results && recommendationsData.results.length > 0) {
                 recommendationsHtml = `
                          <div class="mt-8">
                                ${createCarousel('Títulos Semelhantes', recommendationsData.results, 'recommendations-carousel')}
                          </div>
                     `;
            }

            modalContent.innerHTML = `
            <div class="relative">
                <button id="close-modal-btn" class="absolute top-4 right-4 text-white bg-black bg-opacity-60 rounded-full w-10 h-10 flex items-center justify-center text-xl z-20">&times;</button>
                
                <div class="h-[60vh] bg-cover bg-center relative" style="background-image: url('${backdropPath}');">
                    <div class="modal-gradient absolute inset-0"></div>
                    <div class="absolute bottom-0 left-0 p-4 sm:p-8 z-10 w-full md:w-3/5">
                        <h2 class="text-3xl sm:text-5xl font-bold">${title}</h2>
                        <div class="flex items-center flex-wrap gap-3 mt-4">
                            <button class="play-movie-btn flex items-center justify-center gap-2 px-6 py-2 rounded font-semibold bg-white text-black text-lg hover:bg-gray-200">
                                <i class="fas fa-play"></i> Assistir
                            </button>
                            ${trailerButtonHtml}
                            ${listButtonHtml}
                        </div>
                    </div>
                </div>

                <div class="p-4 sm:p-8">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                        <div class="md:col-span-2">
                             <div class="flex items-center space-x-4 text-gray-300">
                                 <p class="flex items-center font-bold text-lg">
                                     <svg class="w-5 h-5 mr-1 text-yellow-500" fill="currentColor" viewBox="0 0 20 20"><path d="M10 15l-5.878 3.09 1.123-6.545L.489 6.91l6.572-.955L10 0l2.939 5.955 6.572.955-4.756 4.635 1.123 6.545z"></path></svg>
                                     ${details.vote_average.toFixed(1)}
                                 </p>
                                 <p>${year}</p>
                                 ${runtimeText ? `<p>${runtimeText}</p>` : ''}
                                 ${mediaType === 'tv' ? `<p>${details.number_of_seasons} Temporada${details.number_of_seasons > 1 ? 's' : ''}</p>`: ''}
                                 <span class="border px-1 text-xs">${rating}</span>
                               </div>
                             <p class="mt-4 text-base">${overview}</p>
                        </div>
                        <div class="text-sm">
                             <p class="mb-2"><span class="text-gray-400">Elenco: </span>${cast}, mais</p>
                             <p class="mb-2"><span class="text-gray-400">Gêneros: </span>${genres}</p>
                             <p><span class="text-gray-400">Este título é: </span>${keywords}</p>
                        </div>
                    </div>
                    
                    ${mediaType === 'tv' ? `
                    <div id="episodes-section" class="mt-8">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-2xl font-bold">Episódios</h3>
                            <select id="season-selector" class="custom-select">
                                ${details.seasons.filter(s => s.season_number > 0).map(s => `<option value="${s.season_number}">${s.name}</option>`).join('')}
                            </select>
                        </div>
                        <div id="episode-list-container"></div>
                    </div>
                    ` : ''}
                    ${recommendationsHtml}
                </div>
            </div>`;

            if (mediaType === 'tv') {
                const seasonSelector = document.getElementById('season-selector');
                seasonSelector.addEventListener('change', (e) => {
                    renderEpisodeList(details.id, e.target.value);
                });
                renderEpisodeList(details.id, seasonSelector.value);
            }
        };

        const renderPlayerEpisodeList = async (mediaId, currentSeasonNum, currentEpisodeNum) => {
            const panel = document.getElementById('player-episode-panel');
            if (!panel) return;

            const seasons = currentMediaData.seasons.filter(s => s.season_number > 0);
            const seasonDetails = await fetchTMDB(`/tv/${mediaId}/season/${currentSeasonNum}`);

            if (!seasonDetails || !seasonDetails.episodes) {
                panel.innerHTML = '<p class="p-4 text-gray-400">Não foi possível carregar os episódios.</p>';
                return;
            }

            panel.innerHTML = `
                <div class="p-4">
                    <div class="flex justify-between items-center mb-4 h-10">
                        <div class="flex-1">
                           <h3 class="text-xl font-bold">Episódios</h3>
                        </div>
                        <div class="flex-shrink-0">
                            <select id="player-season-selector" class="custom-select player-season-select">
                                ${seasons.map(s => `<option value="${s.season_number}" ${s.season_number == currentSeasonNum ? 'selected' : ''}>${s.name}</option>`).join('')}
                            </select>
                        </div>
                        <div class="flex-1 flex justify-end">
                            <button id="close-player-episodes-btn" class="text-3xl text-gray-400 hover:text-white">&times;</button>
                        </div>
                    </div>
                    <div id="player-episode-list" class="flex flex-col gap-2">
                        ${seasonDetails.episodes.map(ep => `
                            <div class="episode-item flex items-start gap-3 p-2 rounded-lg cursor-pointer ${ep.episode_number == currentEpisodeNum ? 'playing' : ''}" data-season-number="${currentSeasonNum}" data-episode-number="${ep.episode_number}">
                                <img src="${ep.still_path ? `https://image.tmdb.org/t/p/w200${ep.still_path}` : NO_POSTER_URL}" alt="${ep.name}" class="w-28 object-cover rounded-md aspect-video">
                                <div class="flex-1">
                                    <h4 class="font-bold text-sm">${ep.episode_number}. ${ep.name}</h4>
                                    <p class="text-xs text-gray-400 mt-1">${ep.overview.substring(0, 80)}${ep.overview.length > 80 ? '...' : ''}</p>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;

            const seasonSelector = document.getElementById('player-season-selector');
            if (seasonSelector) {
                seasonSelector.addEventListener('change', (e) => {
                    renderPlayerEpisodeList(mediaId, e.target.value, 1);
                });
            }
        };


        const showCustomPlayer = ({ mediaId, mediaType, season = 1, episode = 1, isTrailer = false, trailerKey = '' }) => {
            let playerUrl = '';
            let titleText = currentMediaData?.title || currentMediaData?.name || '';
            let nextEpisodeButtonHtml = '';
            let episodeListButtonHtml = '';

            modal.classList.add('player-mode');
            modalContent.classList.add('player-mode-content');

            if (isTrailer) {
                playerUrl = `https://www.youtube.com/embed/${trailerKey}?autoplay=1`;
                titleText = `${titleText} (Trailer)`;
            } else {
                saveToWatchedHistory(currentMediaData);
                if (mediaType === 'tv') {
                    playerUrl = `https://vidsrc.xyz/embed/tv/${mediaId}/${season}/${episode}?ds_lang=pt`;
                    titleText = `${titleText} - T${season}:E${episode}`;
                    
                    const currentSeason = currentMediaData.seasons.find(s => s.season_number === Number(season));
                    if (currentSeason && episode < currentSeason.episode_count) {
                        const nextEpisode = Number(episode) + 1;
                        nextEpisodeButtonHtml = `<button id="next-episode-btn" class="player-control-btn" title="Próximo Episódio" data-season="${season}" data-episode="${nextEpisode}"><i class="fas fa-step-forward"></i></button>`;
                    }
                    episodeListButtonHtml = `<button id="toggle-episodes-btn" class="player-control-btn" title="Lista de Episódios"><i class="fas fa-list-ul"></i></button>`;
                } else {
                    playerUrl = `https://vidsrc.xyz/embed/movie/${mediaId}?ds_lang=pt`;
                }
            }

            modalContent.innerHTML = `
                <div class="w-full h-full relative bg-black overflow-hidden">
                    <div id="custom-player-container" class="w-full h-full">
                        <iframe src="${playerUrl}" class="absolute top-0 left-0 w-full h-full border-0" allow="autoplay; fullscreen; picture-in-picture; encrypted-media; gyroscope; accelerometer; clipboard-write" allowfullscreen></iframe>
                        <div id="player-controls-overlay">
                            <div class="flex justify-between items-center w-full p-4">
                                <!-- Controles da Esquerda (Back e Título) -->
                                <div class="flex items-center gap-4">
                                    <button id="back-to-details-btn" class="player-control-btn" title="Voltar"><i class="fas fa-arrow-left"></i></button>
                                    <h3 class="text-xl font-bold truncate">${titleText}</h3>
                                </div>
                                <!-- Controles da Direita (Episódios e Próximo) -->
                                <div class="flex items-center gap-4">
                                    ${episodeListButtonHtml}
                                    ${nextEpisodeButtonHtml}
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="player-episode-panel"></div>
                </div>`;

            if (mediaType === 'tv' && !isTrailer) {
                renderPlayerEpisodeList(mediaId, season, episode);
            }
        };
        
        contentArea.addEventListener('click', async e => {
            const heroPlayBtn = e.target.closest('.hero-play-btn');
            if (heroPlayBtn) {
                const { id, type } = heroPlayBtn.dataset;
                const mediaDetails = await fetchTMDB(`/${type}/${id}`); 
                if (mediaDetails) {
                    currentMediaData = mediaDetails;
                    showModal();
                    showCustomPlayer({ mediaId: id, mediaType: type });
                }
                return;
            }

            const heroInfoBtn = e.target.closest('.hero-info-btn');
            if (heroInfoBtn) {
                renderDetailsModal(heroInfoBtn.dataset.id, heroInfoBtn.dataset.type);
                return;
            }

            const card = e.target.closest('.media-card');
            if (card) { renderDetailsModal(card.dataset.id, card.dataset.type); return; }
            
            const arrow = e.target.closest('.carousel-arrow');
            if (arrow) {
                const carousel = document.getElementById(arrow.dataset.carousel);
                if (carousel) {
                    const section = carousel.closest('.carousel-section');
                    const originalItemCount = parseInt(section.dataset.originalItemCount, 10);
                    const firstCard = carousel.querySelector('.media-card');
                    if (!firstCard || originalItemCount < 1) return;

                    const gap = window.innerWidth < 768 ? 12 : 16;
                    const scrollAmount = firstCard.offsetWidth + gap;
                    const totalOriginalWidth = originalItemCount * scrollAmount;
                    
                    const duration = 300;

                    if (arrow.dataset.direction === "1") { // Seta Direita
                        let newScrollLeft = carousel.scrollLeft + scrollAmount;
                        smoothScrollTo(carousel, newScrollLeft, duration, () => {
                            if (carousel.scrollLeft >= totalOriginalWidth) {
                                carousel.scrollLeft -= totalOriginalWidth;
                            }
                        });
                    } else { // Seta Esquerda
                        if (carousel.scrollLeft < scrollAmount) {
                            carousel.scrollLeft += totalOriginalWidth;
                        }
                        let newScrollLeft = carousel.scrollLeft - scrollAmount;
                        smoothScrollTo(carousel, newScrollLeft, duration);
                    }
                }
            }
        });

        modal.addEventListener('click', e => { if (e.target === modal || e.target.closest('#close-modal-btn')) hideModal(); });
        
        modalContent.addEventListener('click', e => {
            if (e.target.closest('.play-movie-btn')) { 
                showCustomPlayer({
                    mediaId: currentMediaData.id,
                    mediaType: currentMediaData.seasons ? 'tv' : 'movie'
                });
                return;
            }
            const episodeItem = e.target.closest('.episode-item');
            if (episodeItem) { 
                const { seasonNumber, episodeNumber } = episodeItem.dataset; 
                showCustomPlayer({
                    mediaId: currentMediaData.id,
                    mediaType: 'tv',
                    season: seasonNumber,
                    episode: episodeNumber
                });
                return; 
            }
            if (e.target.closest('#back-to-details-btn')) { 
                renderDetailsModal(currentMediaData.id, currentMediaData.title ? 'movie' : 'tv'); 
                return; 
            }
        
            const listBtn = e.target.closest('#add-to-list-btn');
            if (listBtn) {
                const wasAdded = toggleMyList(currentMediaData);
                listBtn.innerHTML = wasAdded ? checkIcon : plusIcon;
                listBtn.setAttribute('title', wasAdded ? 'Remover da Minha Lista' : 'Adicionar à Minha Lista');
                return;
            }

            const trailerBtn = e.target.closest('.play-trailer-btn');
            if (trailerBtn) {
                const trailerKey = trailerBtn.dataset.trailerKey;
                showCustomPlayer({
                    mediaId: currentMediaData.id,
                    mediaType: currentMediaData.title ? 'movie' : 'tv',
                    isTrailer: true,
                    trailerKey: trailerKey
                });
                return;
            }

            const nextEpisodeBtn = e.target.closest('#next-episode-btn');
            if (nextEpisodeBtn) {
                const { season, episode } = nextEpisodeBtn.dataset;
                showCustomPlayer({
                    mediaId: currentMediaData.id,
                    mediaType: 'tv',
                    season: season,
                    episode: episode
                });
                return;
            }

            const toggleEpisodesBtn = e.target.closest('#toggle-episodes-btn');
            if (toggleEpisodesBtn) {
                const panel = document.getElementById('player-episode-panel');
                if (panel) {
                    panel.classList.toggle('open');
                }
                return;
            }

            const closePlayerEpisodesBtn = e.target.closest('#close-player-episodes-btn');
            if (closePlayerEpisodesBtn) {
                const panel = document.getElementById('player-episode-panel');
                if (panel) {
                    panel.classList.remove('open');
                }
                return;
            }

            const card = e.target.closest('.media-card');
            if (card) { renderDetailsModal(card.dataset.id, card.dataset.type); return; }
        });
        
        mainNav.addEventListener('click', e => {
            e.preventDefault();
            const link = e.target.closest('.nav-link');
            if (link && !link.classList.contains('active')) {
                navigateTo(link.dataset.page);
            }
        });
        
        logo.addEventListener('click', (e) => {
            e.preventDefault();
            if(currentPage !== 'discover') {
                navigateTo('discover');
            }
        });

        searchButton.addEventListener('click', (e) => {
            e.stopPropagation();
            searchContainer.classList.add('active');
            searchBar.focus();
        });

        document.addEventListener('click', () => {
             if (searchBar.value.trim() === '') {
                 searchContainer.classList.remove('active');
             }
        });

        searchBar.addEventListener('click', e => e.stopPropagation());
        
        let searchTimeout;
        searchBar.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            const query = e.target.value.trim();
            searchTimeout = setTimeout(() => {
                if (query) {
                    if (currentPage !== 'search') {
                         navigateTo('search');
                    }
                    renderSearchResults(query);
                } else {
                    navigateTo('discover');
                }
            }, 500);
        });

        window.addEventListener('scroll', () => { header.classList.toggle('bg-black', window.scrollY > 50); header.classList.toggle('bg-opacity-90', window.scrollY > 50); }, { passive: true });
        
        // --- INICIALIZAÇÃO DA APLICAÇÃO (MODIFICADO) ---
        const splashScreen = document.getElementById('splash-screen');
        const splashVideo = document.getElementById('splash-video');
        const skipIntroBtn = document.getElementById('skip-intro');
        const appContainer = document.getElementById('app-container');
        let appStarted = false;

        function startApp() {
            if (appStarted) return; // Previne múltiplos inícios
            appStarted = true;

            // Fade out splash screen
            splashScreen.style.opacity = '0';
            splashScreen.addEventListener('transitionend', () => {
                splashScreen.remove();
            }, { once: true });

            // Fade in main app
            appContainer.style.opacity = '1';

            // Inicia a navegação principal
            navigateTo('discover');
        }

        // Event listeners para iniciar o app
        splashVideo.addEventListener('ended', startApp);
        skipIntroBtn.addEventListener('click', startApp);

        // Tratamento para casos onde o autoplay pode falhar
        splashVideo.play().catch(error => {
            console.warn("A reprodução automática falhou, iniciando o app.", error);
            // Se o play falhar, inicia o app imediatamente
            startApp();
        });

    });
    </script>
</body>
</html>

